<!DOCTYPE html>
<html>
    <head>
        <title>
            CubicVR.js: AMMO physics adapter test
        </title>
        <script src="ammo.fast.js" type="text/javascript"></script>
        <script src="CubicVR.min.js" type="text/javascript"></script>
        <script type='text/javascript'>
var spawnObjs = 2;

function generateObjects() {
    var result = [];

    var astModel = CubicVR.loadCollada("models/asteroids1.dae", "models/");

    // Add a ast to mesh, size 1.0
    var astMesh = astModel.getSceneObject("asteroid1hull").getMesh();

    var astCollision = new CubicVR.CollisionMap({
        type: CubicVR.enums.collision.shape.CONVEX_HULL,
        mesh: astMesh,
    });

    result.push({mesh:astMesh,collision:astCollision});

    return result;
}

function spawnObjects(scene,physics,objlist) {
    var nobjs = objlist.length;

    var b = parseInt(window.location.search.substr(1),10);
    if (b && !(b!=b)) spawnObjs = b;

    for (var i = 0; i < spawnObjs; i++) {
        var src = objlist[i%nobjs];

        var sceneObj = new CubicVR.SceneObject({
            name: "ast_obj" + i,
            mesh:src.mesh,
            position:[(Math.random()-0.5)*2.0*10,0,(Math.random()-0.5)*2.0*10],
            rotation:[0,0,0]
        });

        var rigidObj = new CubicVR.RigidBody(sceneObj, {
            name: "ast_rigid" + i,
            type: "dynamic",
            mass: 1,
            collision: src.collision
        });
        console.log(sceneObj);
        console.log(rigidObj);

        scene.bind(sceneObj);
        physics.bind(rigidObj);
    }
}

function webGLStart() {
    // by default generate a full screen canvas with automatic resize
    var gl = CubicVR.init();
    var canvas = CubicVR.getCanvas();

    if (!gl) {
        alert("Sorry, no WebGL support.");
        return;
    };

    // New scene with our canvas dimensions and default camera with FOV 80
    var scene = new CubicVR.Scene({
        camera: {
            width: canvas.width,
            height: canvas.height,
            fov: 80,
            position: [5, 5, -5],
            target: [0, -3, 0]
        },
        light: {
            type: "area",
            intensity: 0.9,
            mapRes: 2048,
            areaCeiling: 40,
            areaFloor: -40,
            areaAxis: [-2,-2], // specified in degrees east/west north/south
            distance: 60
        }
    });

    CubicVR.setSoftShadows(true);

    var floorMesh = new CubicVR.Mesh({
        primitive: {
            type: "box",
            size: 1.0,
            material: {
                color: [0.9, 0.8, 0.7]
            },
        },
        compile:true
    });

    var floorObject = new CubicVR.SceneObject({
        mesh: floorMesh,
        scale: [100, 0.2, 100],
        position: [0, -5, 0],
    });

    floorObject.shadowCast = false;

    // init physics manager
    var physics = new CubicVR.ScenePhysics();

    // create floor rigid body
    var rigidFloor = new CubicVR.RigidBody(floorObject, {
        type: "static",
        collision: {
            type: "box",
            size: floorObject.scale
        }
    });
    // bind floor to physics
    physics.bind(rigidFloor);

    // Add SceneObject containing the mesh to the scene
    scene.bind(floorObject);

    // initialize a mouse view controller
    mvc = new CubicVR.MouseViewController(canvas, scene.camera);

    // Add our scene to the window resize list
    CubicVR.addResizeable(scene);

    var objlist = generateObjects();
    spawnObjects(scene,physics,objlist);

    var pickConstraint = null;
    var pickDist = 0;

    var fracture = function(ray, hit) {
        var rigid = hit.rigidBody;
        var obj = rigid.sceneObject;
        var hull = rigid.shape;

        /*
        for (var i = 0; i < hull.getNumEdges(); i++) {
            var p1 = new btVector3();
            var p2 = new btVector3();
            hull.getEdge(i, p1, p2);
            console.log(
                [p1.x(), p1.y(), p1.z(), p1.w()],
                [p2.x(), p2.y(), p2.z(), p2.w()]);
        }
        */

        scene.remove(obj);
        physics.remove(rigid);

        var newShard = function(sceneObj, rigidObj) {
            scene.bind(sceneObj);
            physics.bind(rigidObj);
        };

        // TODO
        {
            // test code: adds back a clone of the original object
            var o = obj.clone();
            var r = new CubicVR.RigidBody(o, {
                name: rigid.name + "_" + i,
                type: "dynamic",
                mass: 1,
                collision: objlist[0].collision
            });
            newShard(o, r);
        }
    };

    mvc.setEvents({
        mouseMove: function (ctx, mpos, mdelta, keyState) {
            if (!ctx.mdown) return;

            if (pickConstraint) {
                pickConstraint.setPosition(scene.camera.unProject(mpos[0],mpos[1],pickDist));
            } else {
                ctx.orbitView(mdelta);
            }
            //          ctx.panView(mdelta);
        },
        mouseWheel: function (ctx, mpos, wdelta, keyState) {
            ctx.zoomView(wdelta);
        },
        mouseDown: function (ctx, mpos, keyState) {
            var rayTo = scene.camera.unProject(mpos[0],mpos[1]);
            var result = physics.getRayHit(scene.camera.position,rayTo);

            if (keyState[CubicVR.keyboard.CTRL]) {
                if (result) {
                    fracture(rayTo, result);
                }
            } else if (result && !pickConstraint) {
                pickConstraint = new CubicVR.Constraint({
                    type: CubicVR.enums.physics.constraint.P2P,
                    rigidBody: result.rigidBody,
                    positionA: result.localPosition
                });

                physics.addConstraint(pickConstraint);
                pickDist = CubicVR.vec3.length(CubicVR.vec3.subtract(scene.camera.position,result.position));
                pickConstraint.setPosition(scene.camera.unProject(mpos[0],mpos[1],pickDist));
            }

        },
        mouseUp: function(ctx, mpos, keyState) {
            if (pickConstraint) {
                physics.removeConstraint(pickConstraint);
                pickConstraint = null;
            }
        },
        keyDown: null,
        keyUp: null
    });

    window.addEventListener("keypress",function(evt) { physics.reset(); },false);

    // Start our main drawing loop, it provides a timer and the gl context as parameters
    CubicVR.MainLoop(function(timer, gl) {
        physics.stepSimulation(timer.getLastUpdateSeconds());

        scene.render();
    });
}
        </script>
    </head>
    <body onLoad="webGLStart();"></body>
</html>
