<!DOCTYPE html>
<html>
    <head>
        <title>
            CubicVR.js: AMMO physics adapter test
        </title>
        <script src ="stats/build/stats.min.js" type ="text/javascript"></script>
        <script src="js/ammo.fast.js" type="text/javascript"></script>
        <script src="js/CubicVR.min.js" type="text/javascript"></script>

        <script type="text/x-opencl" id="fracturecl">
kernel void fracture(
        /* 0 */ uint vertcount,
        /* 1 */ global float *verts,
        /* 2 */ uint facecount,
        /* 3 */ global uint  *faces,
        /* 4 */ global float *vertout
        )
{
    uint idx = get_global_id(0);
    if (idx > vertcount) {
        return;
    }

    vertout[3 * idx + 0] = verts[3 * idx + 0];
    vertout[3 * idx + 1] = verts[3 * idx + 1] + 1.0;
    vertout[3 * idx + 2] = verts[3 * idx + 2];
}
        </script>

        <script type="text/javascript">
function loadKernel(id) {
    var kernelElement = document.getElementById(id);
    var kernelSource = kernelElement.text;
    if (kernelElement.src != "") {
        var mHttpReq = new XMLHttpRequest();
        mHttpReq.open("GET", kernelElement.src, false);
        mHttpReq.send(null);
        kernelSource = mHttpReq.responseText;
    }
    return kernelSource;
}

function initCL() {
    var ctx = webcl.createContext();
    var kernelSrc = loadKernel("fracturecl");
    var program = ctx.createProgram(kernelSrc);
    var device = ctx.getInfo(WebCL.CONTEXT_DEVICES)[0];

    try {
        program.build([device], "");
    } catch (e) {
        alert("Failed to build WebCL program. Error "
                + program.getBuildInfo(device, WebCL.PROGRAM_BUILD_STATUS)
                + ":  "
                + program.getBuildInfo(device, WebCL.PROGRAM_BUILD_LOG));
        throw e;
    }

    var cl = {};
    cl.ctx = ctx;
    cl.kernel = program.createKernel("fracture");
    cl.queue = ctx.createCommandQueue(device);
    return cl;
}

function doCL(cl, vertices, faces) {
    var vertcount = vertices.length;
    var facecount = faces.length;

    var vertarr = new Float32Array(vertices.length * 3);
    for (var i = 0; i < vertcount; i++) {
        vertarr[3 * i + 0] = vertices[i][0];
        vertarr[3 * i + 1] = vertices[i][1];
        vertarr[3 * i + 2] = vertices[i][2];
    }

    var facearr = new Uint32Array(faces.length * 3);
    for (var i = 0; i < facecount; i++) {
        facearr[3 * i + 0] = faces[i].points[0];
        facearr[3 * i + 1] = faces[i].points[1];
        facearr[3 * i + 2] = faces[i].points[2];
    }

    var bufInV  = cl.ctx.createBuffer(WebCL.MEM_READ_ONLY , vertcount * 3 * 4);
    var bufInF  = cl.ctx.createBuffer(WebCL.MEM_READ_ONLY , facecount * 3 * 4);
    var bufOutV = cl.ctx.createBuffer(WebCL.MEM_WRITE_ONLY, vertcount * 3 * 4);

    cl.kernel.setArg(0, new Uint32Array([vertcount]));
    cl.kernel.setArg(1, bufInV);
    cl.kernel.setArg(2, new Uint32Array([facecount]));
    cl.kernel.setArg(3, bufInF);
    cl.kernel.setArg(4, bufOutV);

    cl.queue.enqueueWriteBuffer(bufInV, false, 0, vertcount * 3 * 4, vertarr);
    cl.queue.enqueueWriteBuffer(bufInF, false, 0, facecount * 3 * 4, facearr);

    var localWS = [1];
    var globalWS = [vertcount];

    cl.queue.enqueueNDRangeKernel(cl.kernel, globalWS.length, null, globalWS, localWS);

    var newvertarr = new Float32Array(vertcount * 3);
    cl.queue.enqueueReadBuffer(bufOutV, false, 0, vertcount * 3 * 4, newvertarr);
    cl.queue.finish();

    var newfacearr = facearr;

    var newverts = [];
    for (var i = 0; i < newvertarr.length / 3; i++) {
        newverts.push([
                newvertarr[3 * i + 0],
                newvertarr[3 * i + 1],
                newvertarr[3 * i + 2]]);
    }

    var newfaces = [];
    for (var i = 0; i < newfacearr.length / 3; i++) {
        newfaces.push([
                newfacearr[3 * i + 0],
                newfacearr[3 * i + 1],
                newfacearr[3 * i + 2]]);
    }

    return [newverts, newfaces];
}
        </script>

        <script type='text/javascript'>
var spawnObjs = 2;
var fracturePattern;

// Loads in the base mesh to be fractured.
// Currently limited to convex hulls only.
// NOTE: Asteroid.dae is NOT purely convex.
function generateObjects() {
    var result = [];
    
    var astModel = CubicVR.loadCollada("models/icosphere.dae", "models/");
    // Add a ast to mesh, size 1.0
    var astObj = astModel.getSceneObject("Icosphere");
    
    var astMesh = astObj.getMesh();
    
    var astCollision = new CubicVR.CollisionMap({
        type: CubicVR.enums.collision.shape.CONVEX_HULL,
        mesh: astMesh,
    });
    result.push({mesh:astMesh,collision:astCollision});
    
    console.log(astMesh);
    
    return result;
}

// Binds the objects to the renderer and physics engine
function spawnObjects(scene,physics,objlist) {
    var nobjs = objlist.length;

    var b = parseInt(window.location.search.substr(1),10);
    if (b && !(b!=b)) spawnObjs = b;

    for (var i = 0; i < spawnObjs; i++) {
        var src = objlist[i%nobjs];

        var sceneObj = new CubicVR.SceneObject({
            name: "ast_obj" + i,
            mesh:src.mesh,
            position:[(Math.random()-0.5)*2.0*10,0,(Math.random()-0.5)*2.0*10],
            rotation:[0,0,0],
        });
        var rigidObj = new CubicVR.RigidBody(sceneObj, {
            name: "ast_rigid" + i,
            type: "dynamic",
            mass: 1,
            collision: src.collision
        });
        //console.log(sceneObj);
        //console.log(rigidObj);

        scene.bind(sceneObj);
        physics.bind(rigidObj);
    }
}

function zpad(number) {
    if (number <= 999) { number = ("00"+number).slice(-3); }
    return number;
}

// Loads in a fracture pattern as an array of meshes.  Currently at models/icoshatter.dae.
function loadFracturePattern() {
    var result = [];

    var astModel = CubicVR.loadCollada("models/icoshatter.dae", "models/");

    // TODO: make this more flexible with naming, or replace with our own voronoi decomp.
    for (var i = 0; i < 8; i++) {
        var astMesh = astModel.getSceneObject("Icosphere_cell_" + zpad(i)).getMesh();
        var astPos  = astModel.getSceneObject("Icosphere_cell_" + zpad(i)).position;
        
        // Currently also saves in the collision just for debugging.
        var astCollision = new CubicVR.CollisionMap({
            type: CubicVR.enums.collision.shape.CONVEX_HULL,
            mesh: astMesh,
        });
        result.push({mesh:astMesh, position:astPos, collision:astCollision});
    }

    return result;
}

function webGLStart() {
    // by default generate a full screen canvas with automatic resize
    var gl = CubicVR.init();
    var canvas = CubicVR.getCanvas();

    if (!gl) {
        alert("Sorry, no WebGL support.");
        return;
    };

    var cl = initCL();

    // New scene with our canvas dimensions and default camera with FOV 80
    var scene = new CubicVR.Scene({
        camera: {
            width: canvas.width,
            height: canvas.height,
            fov: 80,
            position: [5, 5, -5],
            target: [0, -3, 0]
        },
        light: {
            type: "area",
            intensity: 0.9,
            mapRes: 2048,
            areaCeiling: 40,
            areaFloor: -40,
            areaAxis: [-2,-2], // specified in degrees east/west north/south
            distance: 60
        }
    });

    CubicVR.setSoftShadows(true);

    var floorMesh = new CubicVR.Mesh({
        primitive: {
            type: "box",
            size: 1.0,
            material: {
                color: [0.9, 0.8, 0.7]
            },
        },
        compile:true
    });

    var floorObject = new CubicVR.SceneObject({
        mesh: floorMesh,
        scale: [100, 0.2, 100],
        position: [0, -5, 0],
    });

    floorObject.shadowCast = false;

    // init physics manager
    var physics = new CubicVR.ScenePhysics();

    // create floor rigid body
    var rigidFloor = new CubicVR.RigidBody(floorObject, {
        type: "static",
        collision: {
            type: "box",
            size: floorObject.scale
        }
    });
    // bind floor to physics
    physics.bind(rigidFloor);

    // Add SceneObject containing the mesh to the scene
    scene.bind(floorObject);

    // initialize a mouse view controller
    mvc = new CubicVR.MouseViewController(canvas, scene.camera);

    // Add our scene to the window resize list
    CubicVR.addResizeable(scene);

    var objlist = generateObjects();
    spawnObjects(scene,physics,objlist);

    fracturePattern = loadFracturePattern();
    
    var pickConstraint = null;
    var pickDist = 0;

    // Fractures the hit mesh using fracturePattern.  The geometry of the target mesh is
    //   approximated using its collision convex hull.
    var fracture = function(ray, hit) {
        var rigid = hit.rigidBody;
        var obj = rigid.sceneObject;
        var mesh = obj.getMesh();

        // Attempts to create a wireframe mesh based on the convex hull.

        var points_faces = doCL(cl, mesh.points, mesh.faces);
        var points = points_faces[0];
        var faces = points_faces[1];

        // debug display: adds back a wireframe clone of the original object
        var mesh = new CubicVR.Mesh({
            name: "wireframe",
            wireframe: true,
            buildWireframe: true,
            wireframeMaterial: {
                color: [0.5, 1.0, 0.2]
            }
        });
        mesh.build({
            points: points,
            faces: faces,
            material: {
                color: [0.5, 0.2, 0.2]
            }
        });
        mesh.buildEdges();
        mesh.compile();
        var meshobj = new CubicVR.SceneObject({
                name: "wireframe",      
                mesh:mesh,   
                position:[obj.position[0], obj.position[1], obj.position[2]],   
                rotation:[0,0   ,0],//obj.rotation.slice(0), //copy of the obj's rotation.
                wireframe: true   
            });   
         
        scene.bind(meshobj);
        
        // END: convex hull mesh creation
        
        var newShard = function(sceneObj, rigidObj) {
            scene.bind(sceneObj);
            physics.bind(rigidObj);
        };
        

        // TODO
        for (var i = 0; i < fracturePattern.length; i++) {
            var fracMesh = fracturePattern[i].mesh;
            var fracColl = fracturePattern[i].collision;
            var fracPos = fracturePattern[i].position;
            
            // Intersect each fracture pattern with hull to generate a new hull.
            // Alternatively, intersect mesh with obj.mesh to generate a new mesh.
            
            var o = new CubicVR.SceneObject({
                name: obj.name + "_" + i,   
                mesh:fracMesh,
                position:[obj.position[0] + fracPos[0], obj.position[1] + fracPos[1], obj.position[2] + fracPos[2]],
                rotation:[0,0,0]//obj.rotation.slice(0), //copy of the obj's rotation.
            });
            // Need to pass in the linear and angular velocity as well.
            var r = new CubicVR.RigidBody(o, {
                name: rigid.name + "_" + i,
                type: "dynamic",
                mass: 1,
                collision: fracColl
            });
            
            r.setLinearVelocity(rigid.getLinearVelocity());
            // TODO: Find a solution to conserving angular velocity along the original axis of rotation.  Simply passing it through is incorrect as it spins around a local axis.
            r.setAngularVelocity(rigid.getAngularVelocity());
            
            newShard(o, r);
            //console.log(o);
        }
        
        // Remove the original object.
        scene.remove(obj);
        physics.remove(rigid);
    };

    mvc.setEvents({
        mouseMove: function (ctx, mpos, mdelta, keyState) {
            if (!ctx.mdown) return;

            if (pickConstraint) {
                pickConstraint.setPosition(scene.camera.unProject(mpos[0],mpos[1],pickDist));
            } else {
                ctx.orbitView(mdelta);
            }
            //          ctx.panView(mdelta);
        },
        mouseWheel: function (ctx, mpos, wdelta, keyState) {
            ctx.zoomView(wdelta);
        },
        mouseDown: function (ctx, mpos, keyState) {
            var rayTo = scene.camera.unProject(mpos[0],mpos[1]);
            var result = physics.getRayHit(scene.camera.position,rayTo);

            if (keyState[CubicVR.keyboard.CTRL]) {
                if (result) {
                    fracture(rayTo, result);
                }
            } else if (result && !pickConstraint) {
                pickConstraint = new CubicVR.Constraint({
                    type: CubicVR.enums.physics.constraint.P2P,
                    rigidBody: result.rigidBody,
                    positionA: result.localPosition
                });

                physics.addConstraint(pickConstraint);
                pickDist = CubicVR.vec3.length(CubicVR.vec3.subtract(scene.camera.position,result.position));
                pickConstraint.setPosition(scene.camera.unProject(mpos[0],mpos[1],pickDist));
            }

        },
        mouseUp: function(ctx, mpos, keyState) {
            if (pickConstraint) {
                physics.removeConstraint(pickConstraint);
                pickConstraint = null;
            }
        },
        keyDown: null,
        keyUp: null
    });

    window.addEventListener("keypress",function(evt) {
        if (evt.which == 114) {
            physics.reset();
        }
    },false);

    // Start our main drawing loop, it provides a timer and the gl context as parameters
    CubicVR.MainLoop(function(timer, gl) {
        physics.stepSimulation(timer.getLastUpdateSeconds());

        scene.render();
    });
}
        </script>
    </head>
    <body onLoad="webGLStart();"></body>
</html>
